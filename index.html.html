<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Holographic Birthday Wish</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        /* éšè—è§†é¢‘å…ƒç´ ï¼Œæˆ‘ä»¬åªéœ€è¦æ•°æ® */
        #input-video {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
        }
        #ui-layer {
            position: absolute;
            z-index: 10;
            color: #00ffff;
            text-align: center;
            width: 100%;
            bottom: 30px;
            pointer-events: none;
            text-shadow: 0 0 10px #00ffff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            z-index: 20;
            font-size: 20px;
            background: rgba(0, 20, 40, 0.8);
            padding: 20px;
            border: 1px solid #00ffff;
            border-radius: 10px;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .instruction {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
        }
    </style>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading" onclick="startExperience()">
        <div>ç‚¹å‡»å¼€å§‹å…¨æ¯æŠ•å½±</div>
        <div style="font-size:12px; margin-top:10px; color:#aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <div id="ui-layer">
        <div id="status-text">ç­‰å¾…æ‘„åƒå¤´ä¿¡å·...</div>
        <div class="instruction">ğŸ– å¼ å¼€æ‰‹æŒ: ç”Ÿæ—¥å¿«ä¹ | âœŠ æ¡æ‹³: è›‹ç³•</div>
    </div>

    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

<script>
    // --- é…ç½® ---
    const PARTICLE_COUNT = 4000; // ç²’å­æ•°é‡ï¼Œæ‰‹æœºå¡é¡¿å¯è°ƒå°
    const TEXT_CONTENT = "HAPPY\nBIRTHDAY\n[èªå¨ƒå„¿]"; // ä¿®æ”¹è¿™é‡Œçš„åå­—
    const CAMERA_WIDTH = 1280;
    const CAMERA_HEIGHT = 720;
    
    // --- çŠ¶æ€å˜é‡ ---
    let isRunning = false;
    let handDetected = false;
    let handPosition = new THREE.Vector3(0, 0, 0); // å½’ä¸€åŒ–çš„æ‰‹éƒ¨ä½ç½®
    let gestureState = 'IDLE'; // IDLE, TEXT, CAKE
    
    // --- Three.js å˜é‡ ---
    let scene, camera, renderer;
    let particles, particleGeo, particleMaterial;
    let positions, targetPositions;
    let clock = new THREE.Clock();

    // --- ç›®æ ‡ç‚¹äº‘æ•°æ® ---
    let textPoints = [];
    let cakePoints = [];
    let idlePoints = [];

    // ==========================================
    // 1. åˆå§‹åŒ– Three.js åœºæ™¯
    // ==========================================
    function initScene() {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        createParticles();
        
        window.addEventListener('resize', onWindowResize, false);
    }

    // ==========================================
    // 2. ç²’å­ç³»ç»Ÿä¸ç‚¹äº‘ç”Ÿæˆ
    // ==========================================
    
    // åˆ›å»ºåœ†å½¢è¾‰å…‰çº¹ç†
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // æ ¸å¿ƒäº®é’è‰²
        gradient.addColorStop(0.4, 'rgba(0, 100, 255, 0.5)'); // ä¸­é—´è“ç´«è‰²
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    function createParticles() {
        particleGeo = new THREE.BufferGeometry();
        positions = new Float32Array(PARTICLE_COUNT * 3);
        targetPositions = new Float32Array(PARTICLE_COUNT * 3);

        // åˆå§‹åŒ–æ‰€æœ‰ç²’å­åœ¨éšæœºä½ç½®
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            
            // é»˜è®¤é—²ç½®ç›®æ ‡ä¹Ÿæ˜¯éšæœºçš„
            idlePoints.push({
                x: (Math.random() - 0.5) * 100,
                y: (Math.random() - 0.5) * 100,
                z: (Math.random() - 0.5) * 50
            });
        }

        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            map: createGlowTexture(),
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // å…³é”®ï¼šå‘å…‰å åŠ æ¨¡å¼
            depthWrite: false
        });

        particles = new THREE.Points(particleGeo, particleMaterial);
        scene.add(particles);

        // ç”Ÿæˆå½¢çŠ¶æ•°æ®
        generateTextPoints();
        generateCakePoints();
    }

    // ç”Ÿæˆæ–‡å­—ç‚¹äº‘
    function generateTextPoints() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 1024; // ç”»å¸ƒå¤§ä¸€ç‚¹ä»¥è·å¾—æ¸…æ™°åº¦
        const height = 512;
        canvas.width = width;
        canvas.height = height;

        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);
        
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 120px Arial'; // å­—ä½“å¤§å°
        
        const lines = TEXT_CONTENT.split('\n');
        const lineHeight = 140;
        lines.forEach((line, i) => {
            const yOffset = (i - (lines.length - 1) / 2) * lineHeight;
            ctx.fillText(line, width / 2, height / 2 + yOffset);
        });

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // æ‰«æåƒç´ 
        const validPixels = [];
        for (let y = 0; y < height; y += 4) { // æ­¥é•¿æ§åˆ¶é‡‡æ ·å¯†åº¦
            for (let x = 0; x < width; x += 4) {
                const index = (y * width + x) * 4;
                if (data[index] > 128) { // å¦‚æœæ˜¯ç™½è‰²åƒç´ 
                    validPixels.push({
                        x: (x - width / 2) * 0.15, // ç¼©æ”¾å› å­
                        y: -(y - height / 2) * 0.15, // åè½¬Yè½´
                        z: 0
                    });
                }
            }
        }
        
        // å¡«å……åˆ° textPoints æ•°ç»„ï¼Œå¦‚æœç‚¹ä¸å¤Ÿå°±å¾ªç¯ä½¿ç”¨ï¼Œå¦‚æœå¤šäº†å°±æˆªæ–­
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = validPixels[i % validPixels.length];
            // åŠ ä¸€ç‚¹éšæœºZè½´åšåº¦
            textPoints.push({ x: p.x, y: p.y, z: (Math.random() - 0.5) * 5 }); 
        }
    }

    // ç”Ÿæˆè›‹ç³•å½¢çŠ¶ç‚¹äº‘
    function generateCakePoints() {
        // è›‹ç³•åº•éƒ¨
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            const ratio = i / PARTICLE_COUNT;
            
            if (ratio < 0.6) {
                // è›‹ç³•ä½“ (ä¸¤å±‚åœ†æŸ±)
                const layer = ratio < 0.3 ? 10 : 7; // åŠå¾„
                const heightBase = ratio < 0.3 ? -10 : -3;
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * layer; // å‡åŒ€åˆ†å¸ƒåœ¨åœ†å†…
                
                x = Math.cos(angle) * r;
                z = Math.sin(angle) * r; // è¿™é‡Œçš„zå…¶å®æ˜¯æ·±åº¦ï¼Œä½†åœ¨3Dé‡Œæˆ‘ä»¬æš‚ç”¨zåšæ·±åº¦
                y = heightBase + Math.random() * 5; 
            } else if (ratio < 0.8) {
                // èœ¡çƒ›
                x = 0;
                z = 0;
                y = 3 + Math.random() * 8;
            } else {
                // ç«ç„° (é¡¶éƒ¨å‘æ•£)
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 2;
                x = Math.cos(angle) * r;
                z = Math.sin(angle) * r;
                y = 11 + Math.random() * 4;
            }
            
            cakePoints.push({ x: x * 1.5, y: y * 1.5, z: z * 1.5 });
        }
    }

    // ==========================================
    // 3. MediaPipe æ‰‹åŠ¿è¯†åˆ«
    // ==========================================
    function initMediaPipe() {
        const videoElement = document.getElementById('input-video');
        
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: CAMERA_WIDTH,
            height: CAMERA_HEIGHT
        });
        
        return cameraUtils;
    }

    function onResults(results) {
        const uiText = document.getElementById('status-text');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. è·å–æ‰‹æŒä¸­å¿ƒä½ç½® (å½’ä¸€åŒ– 0-1)
            // ç´¢å¼•9æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œ0æ˜¯æ‰‹è…•ï¼Œå–ä¸­é—´
            const palmX = (landmarks[0].x + landmarks[9].x) / 2;
            const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            
            // æ˜ å°„åˆ° Three.js åæ ‡ç³» (åè½¬Xè½´å› ä¸ºè‡ªæ‹é•œåƒæ˜¯åçš„)
            // è§†å£å¤§çº¦å®½60, é«˜30 (æ ¹æ®æ‘„åƒæœºZ=50ä¼°ç®—)
            handPosition.x = (0.5 - palmX) * 60; 
            handPosition.y = (0.5 - palmY) * 40;

            // 2. ç®€æ˜“æ‰‹åŠ¿è¯†åˆ«
            // è®¡ç®—æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)çš„è·ç¦»
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // è·ç¦»é˜ˆå€¼éœ€è¦è°ƒè¯•ï¼Œé€šå¸¸ 0.05-0.1 ç®—æåˆ/æ¡æ‹³
            if (distance < 0.05) {
                gestureState = 'CAKE';
                uiText.innerText = "ç”Ÿæˆï¼šç”Ÿæ—¥è›‹ç³• ğŸ‚";
                // æ”¹å˜é¢œè‰²æ¨¡æ‹Ÿç«ç„°
                particleMaterial.color.setHex(0xffaa00);
            } else {
                gestureState = 'TEXT';
                uiText.innerText = "ç”Ÿæˆï¼šç¥ç¦æ–‡å­— âœ¨";
                // æ¢å¤å…¨æ¯è“
                particleMaterial.color.setHex(0x00ffff);
            }

        } else {
            handDetected = false;
            gestureState = 'IDLE';
            uiText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œæ˜¾ç¤ºå¾…æœºç²’å­";
            particleMaterial.color.setHex(0x0055ff);
        }
    }

    // ==========================================
    // 4. åŠ¨ç”»å¾ªç¯ä¸é€»è¾‘
    // ==========================================
    
    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsArray = particleGeo.attributes.position.array;

        // ç¡®å®šå½“å‰åº”è¯¥å»å“ªä¸ªç›®æ ‡é›†åˆ
        let currentTargetSet = idlePoints;
        if (handDetected) {
            if (gestureState === 'TEXT') currentTargetSet = textPoints;
            else if (gestureState === 'CAKE') currentTargetSet = cakePoints;
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = i * 3;
            const py = i * 3 + 1;
            const pz = i * 3 + 2;

            // è·å–åŸºç¡€ç›®æ ‡ä½ç½®
            let tx = currentTargetSet[i % currentTargetSet.length].x;
            let ty = currentTargetSet[i % currentTargetSet.length].y;
            let tz = currentTargetSet[i % currentTargetSet.length].z;

            // å¦‚æœæ£€æµ‹åˆ°æ‰‹ï¼Œç»™æ•´ä½“åŠ ä¸€ä¸ªåç§»é‡ï¼Œè®©ç‰©ä½“è·Ÿéšæ‰‹ç§»åŠ¨
            if (handDetected) {
                tx += handPosition.x;
                ty += handPosition.y;
                // zè½´ç¨å¾®é è¿‘æ‘„åƒæœºä¸€ç‚¹
                tz += 5; 
            } else {
                // å¾…æœºæ¨¡å¼ï¼šç¼“æ…¢æ—‹è½¬
                const angle = time * 0.1 + i * 0.001;
                const r = 30 + Math.sin(time * 0.5 + i) * 10;
                tx = Math.cos(angle) * r;
                ty = Math.sin(angle) * r * 0.5; // å‹æ‰ä¸€ç‚¹
                tz = Math.sin(time * 0.2) * 20;
            }

            // å¢åŠ å™ªç‚¹/æ¼‚æµ®æ„Ÿ (Hologram drift)
            tx += Math.sin(time * 2 + i) * 0.5;
            ty += Math.cos(time * 1.5 + i) * 0.5;

            // ç‰©ç†å¹³æ»‘ç§»åŠ¨ (Lerp)
            // æ¡æ‹³å˜è›‹ç³•æ—¶é€Ÿåº¦å¿«ä¸€ç‚¹ï¼Œå¹³æ—¶æ…¢ä¸€ç‚¹
            const speed = gestureState === 'CAKE' ? 0.08 : 0.05;
            
            positionsArray[px] += (tx - positionsArray[px]) * speed;
            positionsArray[py] += (ty - positionsArray[py]) * speed;
            positionsArray[pz] += (tz - positionsArray[pz]) * speed;
        }

        particleGeo.attributes.position.needsUpdate = true;
        
        // åªæœ‰æ‰‹å¼ å¼€æ—¶æ‰å…è®¸ç›¸æœºè½»å¾®æ™ƒåŠ¨ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
        if (gestureState === 'TEXT') {
            camera.position.x += (handPosition.x * 0.2 - camera.position.x) * 0.05;
            camera.position.y += (handPosition.y * 0.2 - camera.position.y) * 0.05;
        } else {
            // å¤ä½
            camera.position.x += (0 - camera.position.x) * 0.05;
            camera.position.y += (0 - camera.position.y) * 0.05;
        }
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ==========================================
    // å¯åŠ¨æµç¨‹
    // ==========================================
    function startExperience() {
        if (isRunning) return;
        
        document.getElementById('loading').innerText = "åˆå§‹åŒ–ç³»ç»Ÿ...";
        
        initScene();
        
        const cameraUtils = initMediaPipe();
        cameraUtils.start()
            .then(() => {
                document.getElementById('loading').style.display = 'none';
                isRunning = true;
                animate();
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loading').innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–HTTPSè¿æ¥ã€‚";
            });
    }

</script>
</body>
</html>