<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Holographic Birthday Wish V2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #input-video { display: none; }
        #ui-layer { position: absolute; z-index: 10; color: #fff; text-align: center; width: 100%; bottom: 20px; pointer-events: none; text-shadow: 0 0 8px rgba(255,255,255,0.8); }
        .instruction { font-size: 13px; opacity: 0.9; margin: 5px 0; }
        .gesture-icon { font-size: 20px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; z-index: 20; font-size: 18px; background: rgba(0, 20, 40, 0.8); padding: 20px 30px; border: 2px solid #00ffff; border-radius: 10px; pointer-events: auto; cursor: pointer; box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); transition: all 0.3s; }
        #loading:active { transform: translate(-50%, -50%) scale(0.95); }
    </style>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading" onclick="startExperience()">
        <div>ğŸš€ ç‚¹å‡»å¯åŠ¨ V2.0 å¢å¼ºç‰ˆ</div>
        <div style="font-size:12px; margin-top:10px; color:#aaa;">(è¯·å…è®¸æ‘„åƒå¤´æƒé™)</div>
    </div>

    <div id="ui-layer">
        <div id="status-text" style="font-weight:bold; color:#00ffff;">ç­‰å¾…ä¿¡å·...</div>
        <div class="instruction"><span class="gesture-icon">ğŸ–</span> å¼ å¼€: ç”Ÿæ—¥ç¥ç¦ | <span class="gesture-icon">âœŠ</span> æ¡æ‹³: è›‹ç³•</div>
        <div class="instruction"><span class="gesture-icon">ğŸ‘</span> ç«–å¤§æ‹‡æŒ‡: å‘å°„çˆ±å¿ƒ (æ–°åŠŸèƒ½!)</div>
    </div>

    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

<script>
    // --- V2 é…ç½® ---
    const PARTICLE_COUNT = 5000; // å¢åŠ ç²’å­æ•°é‡ä»¥è·å¾—æ›´ä¸°å¯Œçš„è§†è§‰
    // ä¿®æ”¹åå­—ï¼šåœ¨æ¢è¡Œç¬¦ \n ä¹‹é—´åŠ ä¸Šåå­—
    const TEXT_CONTENT = "HAPPY\nBIRTHDAY\nå®è´"; 
    
    let isRunning = false;
    let handDetected = false;
    let handPosition = new THREE.Vector3(0, 0, 0);
    let thumbTipPosition = new THREE.Vector3(0, 0, 0); // æ–°å¢ï¼šè¿½è¸ªæ‹‡æŒ‡å°–
    let gestureState = 'IDLE'; // IDLE, TEXT, CAKE, HEART
    
    let scene, camera, renderer, particles, particleGeo, particleMaterial;
    let clock = new THREE.Clock();

    // æ•°æ®ç‚¹äº‘
    let textPoints = [], cakePoints = [], heartPoints = [], idlePoints = [];
    // ç²’å­é¢å¤–å±æ€§ (ç”¨äºçˆ±å¿ƒåŠ¨ç”»)
    let particleAttributes = [];

    function initScene() {
        scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹èƒŒæ™¯è¿·é›¾ï¼Œå¢åŠ æ·±åº¦æ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 55;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶æœ€å¤§åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        createParticles();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64; // æ›´é«˜åˆ†è¾¨ç‡çš„çº¹ç†
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        // V2: ä½¿ç”¨ç™½è‰²ä½œä¸ºæ ¸å¿ƒï¼Œæ–¹ä¾¿åç»­é€šè¿‡æè´¨æŸ“è‰²
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.Texture(canvas);
    }

    function createParticles() {
        particleGeo = new THREE.BufferGeometry();
        let positions = new Float32Array(PARTICLE_COUNT * 3);
        let colors = new Float32Array(PARTICLE_COUNT * 3); // V2: å¯ç”¨é¡¶ç‚¹é¢œè‰²

        const baseHue = Math.random();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // åˆå§‹éšæœºä½ç½®
            positions[i * 3] = (Math.random() - 0.5) * 300;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 300;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            
            // åˆå§‹åŒ–é¢œè‰² (è™½ç„¶ä¼šè¢«åŠ¨ç”»è¦†ç›–ï¼Œä½†å…ˆç»™ä¸ªåˆå€¼)
            const color = new THREE.Color();
            color.setHSL((baseHue + i * 0.0001) % 1, 0.8, 0.5);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;

            // å¾…æœºçŠ¶æ€çš„éšæœºæ¼‚æµ®ç‚¹
            idlePoints.push({
                x: (Math.random() - 0.5) * 150,
                y: (Math.random() - 0.5) * 150,
                z: (Math.random() - 0.5) * 80
            });

            // V2: æ¯ä¸ªç²’å­çš„ç‹¬ç«‹å±æ€§ï¼Œç”¨äºçˆ±å¿ƒåŠ¨ç”»
            particleAttributes.push({
                heartOffset: Math.random() * Math.PI * 2, // çˆ±å¿ƒè·¯å¾„åç§»
                speed: 0.02 + Math.random() * 0.04, // ä¸ªä½“é€Ÿåº¦å·®å¼‚
                size: 0.5 + Math.random() * 1.5 // ä¸ªä½“å¤§å°å·®å¼‚
            });
        }

        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        let glowTexture = createGlowTexture();
        glowTexture.needsUpdate = true;

        particleMaterial = new THREE.PointsMaterial({
            size: 2.5, // æ•´ä½“ç²’å­å˜å¤§ä¸€ç‚¹
            map: glowTexture,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true // V2: å…³é”®ï¼å¯ç”¨é¡¶ç‚¹é¢œè‰²
        });

        particles = new THREE.Points(particleGeo, particleMaterial);
        scene.add(particles);

        generateTextPoints();
        generateCakePoints();
        generateHeartPoints();
    }

    function generateTextPoints() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024; canvas.height = 512;
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        // ä½¿ç”¨æ›´ç²—çš„å­—ä½“
        ctx.font = '900 130px Arial, sans-serif'; 
        const lines = TEXT_CONTENT.split('\n');
        lines.forEach((line, i) => {
            const yOffset = (i - (lines.length - 1) / 2) * 150;
            ctx.fillText(line, canvas.width / 2, canvas.height / 2 + yOffset);
        });
        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const validPixels = [];
        for (let y = 0; y < canvas.height; y += 5) {
            for (let x = 0; x < canvas.width; x += 5) {
                if (data[(y * canvas.width + x) * 4] > 128) {
                    validPixels.push({ x: (x - canvas.width/2)*0.16, y: -(y - canvas.height/2)*0.16, z: 0 });
                }
            }
        }
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = validPixels[i % validPixels.length];
            textPoints.push({ x: p.x, y: p.y, z: (Math.random() - 0.5) * 8 }); 
        }
    }

    function generateCakePoints() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            const ratio = i / PARTICLE_COUNT;
            if (ratio < 0.6) { // è›‹ç³•ä½“
                const layer = ratio < 0.3 ? 11 : 8;
                const hBase = ratio < 0.3 ? -12 : -4;
                const a = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * layer;
                x = Math.cos(a) * r; z = Math.sin(a) * r; y = hBase + Math.random() * 6; 
            } else if (ratio < 0.75) { // èœ¡çƒ›æŸ±
                x = (Math.random()-0.5)*1; z = (Math.random()-0.5)*1; y = 4 + Math.random() * 7;
            } else { // V2: ç«ç„°åŒº (æ›´é›†ä¸­åœ¨é¡¶éƒ¨)
                const a = Math.random() * Math.PI * 2;
                const r = Math.random() * 1.5;
                x = Math.cos(a) * r; z = Math.sin(a) * r; y = 12 + Math.random() * 3;
            }
            cakePoints.push({ x: x*1.6, y: y*1.6, z: z*1.6 });
        }
    }

    // V2: ç”Ÿæˆçˆ±å¿ƒè·¯å¾„ç‚¹
    function generateHeartPoints() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // æˆ‘ä»¬ä¸éœ€è¦é¢„å…ˆç”Ÿæˆé™æ€çˆ±å¿ƒï¼Œæˆ‘ä»¬å°†åŠ¨æ€è®¡ç®—å®ƒä»¬
            // è¿™é‡Œåªéœ€è¦å ä½ç¬¦
            heartPoints.push({ x: 0, y: 0, z: 0 });
        }
    }


    function initMediaPipe() {
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        return new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 1280, height: 720 });
    }

    // V2: å¢å¼ºçš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function onResults(results) {
        const uiText = document.getElementById('status-text');
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            const lm = results.multiHandLandmarks[0];
            // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
            const palmX = (lm[0].x + lm[9].x) / 2;
            const palmY = (lm[0].y + lm[9].y) / 2;
            handPosition.set((0.5 - palmX) * 70, (0.5 - palmY) * 50, 0);
            
            // V2: è®°å½•æ‹‡æŒ‡æŒ‡å°–ä½ç½® (ç”¨äºå‘å°„çˆ±å¿ƒ)
            thumbTipPosition.set((0.5 - lm[4].x) * 70, (0.5 - lm[4].y) * 50, 5);

            // æ‰‹åŠ¿åˆ¤æ–­
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const indexBase = lm[5];
            const pinkyTip = lm[20];

            // è®¡ç®—è·ç¦»
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // V2: ç‚¹èµåˆ¤æ–­ (æ‹‡æŒ‡å°–æ˜æ˜¾é«˜äºé£ŸæŒ‡æ ¹éƒ¨ï¼Œä¸”å…¶ä»–æ‰‹æŒ‡å¼¯æ›²)
            // æ³¨æ„ï¼šyè½´å‘ä¸‹ä¸ºæ­£ï¼Œæ‰€ä»¥â€œé«˜â€æ„å‘³ç€yå€¼å°
            const isThumbsUp = (indexBase.y - thumbTip.y > 0.1) && (indexTip.y > indexBase.y);

            if (isThumbsUp) {
                gestureState = 'HEART';
                uiText.innerHTML = "ğŸ’– çˆ±å¿ƒå‘å°„!";
                uiText.style.color = "#ff66cc";
            } else if (pinchDist < 0.06) {
                gestureState = 'CAKE';
                uiText.innerHTML = "ğŸ‚ ç”Ÿæ—¥è›‹ç³•";
                uiText.style.color = "#ffaa00";
            } else {
                gestureState = 'TEXT';
                uiText.innerHTML = "âœ¨ ç¥ç¦æ–‡å­—";
                uiText.style.color = "#00ffff";
            }
        } else {
            handDetected = false;
            gestureState = 'IDLE';
            uiText.innerHTML = "ç­‰å¾…æ‰‹åŠ¿...";
            uiText.style.color = "#ffffff";
        }
    }

    // ==========================================
    // V2: æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ (è‰²å½©ä¸åŠ¨æ€)
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const positionsAttr = particleGeo.attributes.position;
        const colorsAttr = particleGeo.attributes.color;
        const posArr = positionsAttr.array;
        const colArr = colorsAttr.array;

        // --- V2: åŠ¨æ€è‰²å½©ç®¡ç† ---
        let baseColor = new THREE.Color();
        let hueOffset = time * 0.1; // å…¨å±€è‰²å½©æµåŠ¨é€Ÿåº¦

        if (gestureState === 'CAKE') {
            baseColor.setHSL(0.08, 1.0, 0.6); // æ©™çº¢
        } else if (gestureState === 'HEART') {
            baseColor.setHSL(0.95, 1.0, 0.6); // ç²‰çº¢
        } else {
            // TEXT å’Œ IDLE çŠ¶æ€ï¼šä½¿ç”¨æµå…‰æ¸å˜
            baseColor.setHSL(hueOffset % 1, 0.8, 0.6);
        }
        
        // ç¡®å®šç›®æ ‡
        let currentTargetSet = idlePoints;
        if (handDetected) {
            if (gestureState === 'TEXT') currentTargetSet = textPoints;
            else if (gestureState === 'CAKE') currentTargetSet = cakePoints;
            // HEART çŠ¶æ€ä¸éœ€è¦é™æ€ç›®æ ‡ç‚¹
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = i * 3; const py = i * 3 + 1; const pz = i * 3 + 2;
            const attr = particleAttributes[i];

            // --- V2: æ›´æ–°ç²’å­é¢œè‰² ---
            const pColor = new THREE.Color();
            if (gestureState === 'CAKE' && i > PARTICLE_COUNT * 0.75) {
                // ç«ç„°éƒ¨åˆ†ç‰¹æ®Šå¤„ç†ï¼šé—ªçƒçš„é»„çº¢è‰²
                const flicker = Math.sin(time * 10 + i) * 0.1 + 0.9;
                pColor.setHSL(0.05 + Math.random()*0.05, 1.0, 0.5 * flicker);
            } else if (gestureState === 'TEXT' || gestureState === 'IDLE') {
                 // ç»™æ¯ä¸ªç²’å­åŠ ä¸€ç‚¹è‰²ç›¸åç§»ï¼Œå½¢æˆå½©è™¹æµå…‰
                pColor.setHSL((hueOffset + i * 0.0002) % 1, 0.8, 0.6);
            } else {
                // å…¶ä»–çŠ¶æ€ä½¿ç”¨åŸºå‡†è‰²ï¼Œå¹¶åŠ ä¸€ç‚¹äº®åº¦éšæœº
                pColor.copy(baseColor);
                pColor.multiplyScalar(0.8 + Math.random() * 0.4);
            }
            colArr[px] = pColor.r; colArr[py] = pColor.g; colArr[pz] = pColor.b;


            // --- V2: æ›´æ–°ç²’å­ä½ç½® ---
            let tx, ty, tz;
            let moveSpeed = attr.speed;

            if (gestureState === 'HEART' && handDetected) {
                // === V2 æ–°åŠŸèƒ½: çˆ±å¿ƒå–·å°„é€»è¾‘ ===
                // ç²’å­ä»æ‹‡æŒ‡å°–å‘å°„ï¼Œæ²¿ç€çˆ±å¿ƒå½¢çŠ¶å‘ä¸Šç§»åŠ¨
                // åˆ©ç”¨å–ä½™è¿ç®—è®©ç²’å­å¾ªç¯æµåŠ¨
                const flowTime = (time * 0.5 + attr.heartOffset) % 1; 
                const t = flowTime * Math.PI * 2; // 0 åˆ° 2PI

                // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // åŸºç¡€ä½ç½®åœ¨æ‹‡æŒ‡å°–
                tx = thumbTipPosition.x + hx * 0.8; // 0.8æ˜¯çˆ±å¿ƒå¤§å°ç³»æ•°
                // éšæ—¶é—´å‘ä¸Šé£˜åŠ¨ï¼Œå¹¶æ¸æ¸å˜å¤§æ‰©æ•£
                ty = thumbTipPosition.y + hy * 0.8 + flowTime * 40; 
                tz = thumbTipPosition.z + (Math.random()-0.5) * 10;
                
                moveSpeed = 0.1; // å‘å°„é€Ÿåº¦å¿«ä¸€ç‚¹

            } else {
                // === åŸæœ‰é€»è¾‘ (æ–‡å­—/è›‹ç³•/å¾…æœº) ===
                let targetIndex = i % currentTargetSet.length;
                tx = currentTargetSet[targetIndex].x;
                ty = currentTargetSet[targetIndex].y;
                tz = currentTargetSet[targetIndex].z;

                if (handDetected) {
                    tx += handPosition.x; ty += handPosition.y; tz += 5;
                } else {
                    // å¾…æœºæ¼‚æµ®
                    const a = time * 0.1 + i * 0.001; const r = 35 + Math.sin(time*0.5+i)*10;
                    tx = Math.cos(a)*r; ty = Math.sin(a)*r*0.5; tz = Math.sin(time*0.3)*25;
                }
                // å¢åŠ å™ªç‚¹æ¼‚æµ®
                tx += Math.sin(time * 1.5 + i) * 0.8;
                ty += Math.cos(time * 2.0 + i) * 0.8;
            }

            // å¹³æ»‘ç§»åŠ¨
            posArr[px] += (tx - posArr[px]) * moveSpeed;
            posArr[py] += (ty - posArr[py]) * moveSpeed;
            posArr[pz] += (tz - posArr[pz]) * moveSpeed;
        }

        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true; // V2: é‡è¦ï¼Œæ›´æ–°é¢œè‰²æ•°æ®

        // ç›¸æœºè½»å¾®è·Ÿéšæ™ƒåŠ¨
        const targetCamX = handDetected ? handPosition.x * 0.15 : 0;
        const targetCamY = handDetected ? handPosition.y * 0.15 : 0;
        camera.position.x += (targetCamX - camera.position.x) * 0.05;
        camera.position.y += (targetCamY - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }

    function startExperience() {
        if (isRunning) return;
        document.getElementById('loading').innerText = "âš¡ æ­£åœ¨å¯åŠ¨ V2 å¼•æ“...";
        initScene();
        initMediaPipe().start().then(() => {
            document.getElementById('loading').style.display = 'none';
            isRunning = true;
            animate();
        }).catch(err => {
            document.getElementById('loading').innerText = "å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™ã€‚";
            document.getElementById('loading').style.backgroundColor = "rgba(50,0,0,0.8)";
        });
    }
</script>
</body>
</html>